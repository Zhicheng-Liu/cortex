/*
  dB_graph.c - implementation
 */

#include <stdlib.h>
#include <stdio.h>
#include <binary_kmer.h>
#include <element.h>
#include <dB_graph.h>
#include <string.h>

char * get_seq_from_elem_to_end_of_supernode(dBNode * node, Orientation orientation, dBGraph * db_graph, boolean * is_cycle){
  Nucleotide nucleotide;
  BinaryKmer kmer;
  char * seq = NULL;
  int max = 1000;
  Orientation original_orientation;
  dBNode * original_node;
  int seq_length = 0;

  seq = malloc(1000*sizeof(char)); 

  if (seq == NULL){
    puts("dB_graph: cannot assign memory for sequence\n");
    exit(1);
  }

  original_node = node;
  original_orientation = orientation; 
  

  //Mark the element we're starting at as visited
  db_node_set_visited(node);

  *is_cycle = false;

  
  while(db_node_has_precisely_one_edge(node,orientation,&nucleotide)) {
   

    if ((seq_length+1)>max){
      max+=1000;
      seq = (char*)realloc(seq, sizeof(char) * max);
    }

    if (seq == NULL){
      printf("dB_graph: cannot assign memory\n");
      exit(1);
    }
   
    kmer = element_get_kmer(node);

    if (orientation == reverse){
      kmer = binary_kmer_reverse_complement(kmer,db_graph->kmer_size);
    }

    kmer = binary_kmer_add_nucleotide_shift(kmer,nucleotide, db_graph->kmer_size);

    //get node from table
    node = hash_table_find(element_get_key(kmer,db_graph->kmer_size),db_graph);
    
    if (node == NULL){
      printf("dB_graph: didnt find node in hash table: %s\n", binary_kmer_to_seq(kmer,db_graph->kmer_size));
      exit(1);
    }	       

    orientation = db_node_get_orientation(kmer,node,db_graph->kmer_size);

    if (DEBUG){
      printf("WOULD LIKE TO ADD %c %i\n",binary_nucleotide_to_char(nucleotide),orientation);
    }

    //check for multiple entry edges 
    if (db_node_has_precisely_one_edge(node,opposite_orientation(orientation),&nucleotide)){
      seq[seq_length] =  binary_nucleotide_to_char(nucleotide);
      seq_length++;
      if (DEBUG){
	printf("ADD %c\n",binary_nucleotide_to_char(nucleotide));
      }
    }
    else{
      if (DEBUG){
	printf("Multiple entries\n");
      }
      break;
    }


    //loop
    if ((node == original_node) && (orientation == original_orientation)){      
      *is_cycle = true;
      //remove last addition
      seq_length--;
      break;
    }
           
    db_node_set_visited(node);
  }

  seq[seq_length] = '\0';
  return seq;
}

void db_graph_print_supernode(FILE * file, dBNode * node, dBGraph * db_graph){

  char * seq = NULL;
  char * seq_forward = NULL;
  char * seq_reverse = NULL; 
  char * seq_reverse_reversed = NULL;
  int i;
  int length_reverse = 0;
  boolean is_cycle_forward, is_cycle_reverse;

  if (! db_node_visited(node)){
  
    seq = binary_kmer_to_seq(element_get_kmer(node),db_graph->kmer_size);

    if (DEBUG){
      printf("\nSTART Supernode %s\n",seq);    
      printf("go forward\n");
    }
    
    //compute the forward path until the end of the supernode
    //mark the nodes in the path as visited.
    //return is_cycle_forward == true if the path closes a loop
    seq_forward = get_seq_from_elem_to_end_of_supernode(node,forward,db_graph,&is_cycle_forward);
    
    if (DEBUG){
      printf("NODE c %s\n",seq); 
      printf("NODE f %s\n",seq_forward);
    }
    
    if (! is_cycle_forward){
      
      if (DEBUG){
	printf("go reverse\n");
      }
      
      //compute the reverse path...
      seq_reverse = get_seq_from_elem_to_end_of_supernode(node,reverse,db_graph,&is_cycle_reverse);
      
      if (is_cycle_reverse){
	puts("cycle reverse orientation without cycle in the forward orientation\n");
	exit(1);
      }
      
      if (DEBUG){
	printf("NODE r %s\n",seq_reverse);
      }
      
      length_reverse = strlen(seq_reverse);
    }
    
    seq_reverse_reversed = malloc((length_reverse+1)*sizeof(char));
    
    //reverse the reverse sequence
    for(i=0;i<length_reverse;i++){
      seq_reverse_reversed[i] = reverse_char_nucleotide(seq_reverse[length_reverse-i-1]);
      
    }
    seq_reverse_reversed[length_reverse]='\0';
    
    if (DEBUG){
      printf("NODE rr %s\n",seq_reverse_reversed);
    }
    
    fprintf(file,">NODE\n%s%s%s\n",seq_reverse_reversed,seq,seq_forward); 
    
    free(seq);
    free(seq_forward);
    free(seq_reverse);
    free(seq_reverse_reversed);
  }
  else{
    if (DEBUG){
      printf("\n%qd: visited\n", element_get_kmer(node));
    }
  }
}

